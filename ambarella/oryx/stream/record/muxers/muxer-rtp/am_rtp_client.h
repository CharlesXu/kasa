/*******************************************************************************
 * am_rtp_client.h
 *
 * History:
 *   2015-1-6 - [ypchang] created file
 *
 * Copyright (C) 2008-2015, Ambarella Co, Ltd.
 *
 * All rights reserved. No Part of this file may be reproduced, stored
 * in a retrieval system, or transmitted, in any form, or by any means,
 * electronic, mechanical, photocopying, recording, or otherwise,
 * without the prior consent of Ambarella.
 *
 ******************************************************************************/
#ifndef ORYX_STREAM_RECORD_MUXERS_MUXER_RTP_AM_RTP_CLIENT_H_
#define ORYX_STREAM_RECORD_MUXERS_MUXER_RTP_AM_RTP_CLIENT_H_

#include "am_rtp_msg.h"
#include "rtp.h"
#include "rtcp.h"

#include <atomic>

enum AM_CLIENT_CMD
{
  AM_CLIENT_CMD_ABORT = 'a',
  AM_CLIENT_CMD_STOP  = 's',
  AM_CLIENT_CMD_ACK   = 'k',
};

enum AM_NET_STATE
{
  AM_NET_OK,
  AM_NET_ERROR,
  AM_NET_SLOW,
  AM_NET_PEER_SHUTDOWN,
  AM_NET_BADFD,
};

struct RtpClientConfig;
struct AMRtpClientData
{
    uint32_t        ssrc;        /* generated by RTP session */
    uint32_t        session_id;  /* client identifier        */
    int             proto_fd;    /* protocol server's RTP fd */
    int             tcp_fd;      /* shared with RTSP server  */
    int             udp_fd_rtp;  /* created by RTP session   */
    int             udp_fd_rtcp; /* created by RTP session   */
    std::string     name;
    AMRtpClientInfo client;
    AMRtpClientData(int proto_fd, int fd_tcp,
                    uint32_t session, const AMRtpClientInfo &info);
    ~AMRtpClientData();
    bool init(RtpClientConfig &config);
    int setup_udp_socket(RtpClientConfig &config, uint16_t port);
    struct sockaddr* client_rtp_address(socklen_t *addr_len);
    struct sockaddr* client_rtcp_address(socklen_t *addr_len);
    uint16_t client_rtp_port();
    uint16_t client_rtcp_port();
};

struct RtcpRRPacket
{
    AMRtcpHeader    rtcp_common_head;
    AMRtcpRRPayload rtcp_rr_payload[];
    uint32_t sender_ssrc();
};

struct RtcpSRPacket
{
  AMRtcpHeader rtcp_common_head;
  AMRtcpSRPayload rtcp_sr_payload;
  AMRtcpRRPayload rtcp_rr_payload[];
  uint32_t sender_ssrc();
};


class AMEvent;
class AMThread;
class AMSpinLock;
class AMMuxerRtp;
class AMRtpSession;
class AMRtpClientConfig;

class AMRtpClient
{
    friend class AMMuxerRtp;
    friend class AMRtpSession;

  public:
    static AMRtpClient* create(const std::string &config,
                               int proto_fd,
                               int tcp_fd,
                               int ctrl_fd,
                               uint32_t session,
                               AMMuxerRtp *muxer,
                               const AMRtpClientInfo &clientInfo);

  public:
    bool start();
    void stop();
    void set_enable(bool enable);
    bool is_alive();
    bool is_abort();
    bool is_enable();
    void destroy();
    uint32_t ssrc();
    void inc_ref();
    void set_session(AMRtpSession *session);

  protected:
    AMRtpClient(int ctrl_fd, AMMuxerRtp *muxer);
    virtual ~AMRtpClient();
    bool init(const std::string &config,
              int proto_fd,
              int tcp_fd,
              uint32_t session,
              const AMRtpClientInfo &clientInfo);

  private:
    static void static_rtcp_monitor(void *data);
    static void static_packet_sender(void *data);
    void rtcp_monitor();
    void packet_sender();
    AM_NET_STATE tcp_send(int fd, uint8_t *data, uint32_t len);
    AM_NET_STATE udp_send(int fd, sockaddr *addr, uint8_t *data, uint32_t len);
    AM_NET_STATE send_rtcp_packet(uint8_t *data, uint32_t len);
    void abort_client(bool send_cmd);
    void send_ack();
    bool send_kill_client();
    bool send_thread_cmd(AM_CLIENT_CMD cmd);

  private:
    RtpClientConfig   *m_client_config; /* No need to delete */
    AMRtpClientConfig *m_config;
    AMRtpClientData   *m_client;
    AMSpinLock        *m_lock;
    AMThread          *m_rtcp_monitor;
    AMThread          *m_packet_sender;
    AMEvent           *m_rtp_event;
    AMEvent           *m_rtcp_event;
    AMMuxerRtp        *m_muxer;
    uint8_t           *m_rtcp_sr_buf;
    AMRtcpHeader      *m_rtcp_hdr;
    AMRtcpSRPayload   *m_rtcp_sr;
    AMRtpSession      *m_session;
    int                m_ctrl_fd;
    std::atomic_int    m_ref_count;
    uint64_t           m_start_clock_90k;
    uint64_t           m_tcp_max_speed;
    uint64_t           m_tcp_min_speed;
    uint64_t           m_tcp_avg_speed;
    uint64_t           m_udp_max_speed;
    uint64_t           m_udp_min_speed;
    uint64_t           m_udp_avg_speed;
    uint64_t           m_tcp_send_time;
    uint64_t           m_udp_send_time;
    uint64_t           m_tcp_send_size;
    uint64_t           m_udp_send_size;
    uint32_t           m_tcp_send_count;
    uint32_t           m_udp_send_count;
    bool               m_run;
    bool               m_abort;
    bool               m_enable;
    int                m_ctrl[2];
#define RTP_CLI_R      m_ctrl[0]
#define RTP_CLI_W      m_ctrl[1]
};

#endif /* ORYX_STREAM_RECORD_MUXERS_MUXER_RTP_AM_RTP_CLIENT_H_ */
